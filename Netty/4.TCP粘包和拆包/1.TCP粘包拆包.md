# TCP粘包和拆包基本介绍

1）TCP是面向连接的，面向流的，提供高可靠性服务。收发两端(客户端和服务器端)都要有一一成对的socket，因此，发送端为了将多个发给接收端的包，能更有效的发给对方，使用了优化方法(Nagle算法)，将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为<font color = 'red'>面向流的通信是无消息保护边界的</font>

2）由于TCP无消息保护边界，需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题，看一张图

![](images/1.TCP粘包、拆包.jpg)

假设客户端分别发送了两个数据包D1和D2给服务端，由于**服务端一次读取到字节数是不确定的**，故可能存在以下四种情况:

1)服务端**分两次**读取到了两个独立的数据包分别是D1和D2，没有粘包和拆包

2)服务端**一次**接受到了两个数据包，D1和D2粘合在一起，称之为TCP粘包

3)服务端分两次读取到了数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这称之为TCP拆包

4)服务端分两次读取到了数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余部分内容D1_2和完整的D2包。

tcp 粘包演示

![](images/2.tcp粘包演示.jpg)

![](images/3.tcp粘包演示.jpg)

### TCP 粘包和拆包解决方案

1）使用自定义协议 +编解码器 来解决
2）关键就是要解决 服务器端每次读取数据长度的问题，这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的TCP粘包、拆包。

**自定义解码器实现粘包原理**

![](images/4.自定义解码器实现粘包原理.jpg)

MyServer

```java
package com.luojia.netty.nettypro.netty.tcp.protocoltcp;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioServerSocketChannel;

public class MyServer {
    public static void main(String[] args) throws InterruptedException {
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();

        try {
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new MyServerInitializer());

            ChannelFuture future = serverBootstrap.bind(7001).sync();
            future.channel().closeFuture().sync();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}
```

MyServerInitializer

```java
package com.luojia.netty.nettypro.netty.tcp.protocoltcp;

import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.socket.SocketChannel;

public class MyServerInitializer extends ChannelInitializer<SocketChannel> {
    @Override
    protected void initChannel(SocketChannel ch) throws Exception {
        ChannelPipeline pipeline = ch.pipeline();
        pipeline.addLast(new MyMessageDecoder()); // 解码器
        pipeline.addLast(new MyMessageEncoder()); // 编码器
        pipeline.addLast(new MyServerHandler());
    }
}
```

MyMessageDecoder

```java
package com.luojia.netty.nettypro.netty.tcp.protocoltcp;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.ReplayingDecoder;

import java.util.List;

public class MyMessageDecoder extends ReplayingDecoder<Void> {
    @Override
    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {
        System.out.println("MyMessageDecoder decode 被调用");
        // 需要将得到的二进制字节码 -> MessageProtocol 数据包(对象)
        int len = byteBuf.readInt();
        byte[] content = new byte[len];
        // 将 byteBuf 中数据读取到 content 中
        byteBuf.readBytes(content);

        // 封装成 MessageProtocol 对象，放入 list，传递到下一个handler 业务处理
        MessageProtocol messageProtocol = new MessageProtocol();
        messageProtocol.setLen(len);
        messageProtocol.setContent(content);
        list.add(messageProtocol);
    }
}
```







