# 源码剖析

Netty中的 ChannelPipeline、ChannelHandler 和 ChannelHandlerContext 是非常核心的组件，我们从源码来分析Netty 是如何设计这三个核心组件的，并分析是如何创建和协调工作的。

### ChannelPipeline、ChannelHandler、ChannelHandlerContext 介绍

1)每当 ServerSocket 创建一个新的连接，就会创建一个 Socket，对应的就是目标客户端。

2)每一个新创建的 Socket，都将会分配一个全新的 ChannelPipeline（以下简称 pipeline）

3)每一个 ChannelPipeline 内部都含有多个 ChannelHandlerContext(以下简称 Context)

4)**他们一起组成了双向链表**，这些Context 用于包装我们调用 addLast方法时添加的 ChannelHandler(以下简称handler )

![](images/27.三者关系示意图.jpg)

- 上图中：ChannelSocket 和  ChannePipeline 是一对一的关联关系，而 pipeline 内部的多个 Context 形成了链表，**Context只是对Handler的封装**
- 当一个请求进来的时候，会进入 Socket 对应的 pipeline，并经过 pipeine 所有的 handle，这就是设计模式中的过滤器模式(一般和责任链模式一起)。

### ChannelPipeLine 作用及设计

pipeline 的接口设计

![](images/28.ChannelPipeLine UML.jpg)

可以看到该接口继承了 inBound，outBound，Iterable 接口，表示他可以调用**数据出站的方法和入站**的方法，同时也能遍历内部的链表， 看看他的几个代表性的方法，基本上都是针对 handler 链表的插入，追加，删除，替换操作，类似是一个 LinkedList。同时，也能返回 channel(也就是 socket)

1）在 pipeline 的接口文档上，提供了一幅图

![](images/29.pipeline 文档图.jpg)

**对上图的解释说明：**

这是一个 handler 的 list，handler 用于处理或拦截入站事件和出站事件，pipeline 实现了过滤器的高级形式，以便用户控制事件如何处理以及 handler在pipeline 中如何交互。

上图指述了一个典型的 handler在pipeline中处理I/O事件的方式，IO事件由 inboundhandler 或者 outBoundHandler 处理，并通过调用 channelHandlerContext.fireChannelRead（以 inboundhandler 为例） 方法转发给其最近的处理程序

![](images/30.fireChannelRead解读.jpg)

![](images/31.fireChannelRead解读.jpg)

入站事件由入站处理程序以自下而上的方向处理，如上链表图所示。入站处理程序通常处理由图底部的 I/O 线程生成入站数据。入站数据通常从如 SocketChannel.read(ByteBuffer)获取。

通常一个 pipeline 有多个 handler，例如，一个典型的服务器在每个通道的管道中都会有以下处理程序

​	协议解码器 - 将二进制数据转换为 Java 对象。

​	协议编码器 - 将Java 对象转换为二进制数据。

​	业务逻辑处理程序 - 执行实际业务逻辑(例如数据库访问)

你的业务程序不能将线程阻塞，会影响 IO 的速度，进而影响整个 Netty 程序的性能。如果你的业务程序很快，就可以放在 IO 线程中，反之，你需要异步执行。或者在添加 handler 的时候添加一个线程池，例如:

// 下面这个任务执行的时候，将不会阻塞 IO 线程，执行的线程来自 group 线程池  pipeline,addLast(group, “handler", new lyBusinessLogicHandler())

### ChannelHandler 作用及设计

源码解读：

```java
public interface ChannelHandler {

    // 当把 ChannelHandler 添加到 pipeline 时被调用
    void handlerAdded(ChannelHandlerContext ctx) throws Exception;

    // 当从 pipeline 中移除时被调用
    void handlerRemoved(ChannelHandlerContext ctx) throws Exception;

    // 当处理过程中在 pipeline 发生异常时调用
    @Deprecated
    void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;

}
```

Channelhandler 的作用就是处理 I〇 事件或拦截 IO 事件，并将其转发给下一个处理程序 ChannelHandler。Handler 处理事件时分入站和出站的，两个方向的操作都是不同的，因此，Netty 定义了两个子接口继承ChannelHandler

- ChannelInboundHandler 入站事件接口

  ![](images/32.ChannelInboundHandler 方法.jpg)

  channelActive 用于当 Channel 处于活动状态时被调用；

  channelRead 当从 Channel 读取数据时被调用，等等其他方法。

  程序员需要重写一些方法，当发生关注的事件，需要在方法中实现我们的业务逻辑，因为当事件发生时，Netty 会回调对应的方法。

- ChannelOutboundHandler 出站事件接口

  ![](images/33.ChannelOutboundHandler 方法.jpg)

  bind 方法，当请求将 Channel 绑定到本地地址时调用

  close 方法，当请求关闭 Channel 时调用等等

  出站操作都是一些连接和写出数据类似的方法

- ChannelDuplexHandler 处理出站和入站事件

  ![](images/34.ChannelDuplexHandler 方法.jpg)

  ChannelDuplexHandler : 间接实现了入站接口并直接实现了出站接口。

  是一个通用的能够同时处理入站事件和出站事件的类。



