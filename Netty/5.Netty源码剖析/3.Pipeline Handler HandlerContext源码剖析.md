# 源码剖析

Netty中的 ChannelPipeline、ChannelHandler 和 ChannelHandlerContext 是非常核心的组件，我们从源码来分析Netty 是如何设计这三个核心组件的，并分析是如何创建和协调工作的。

### ChannelPipeline、ChannelHandler、ChannelHandlerContext 介绍

1)每当 ServerSocket 创建一个新的连接，就会创建一个 Socket，对应的就是目标客户端。

2)每一个新创建的 Socket，都将会分配一个全新的 ChannelPipeline（以下简称 pipeline）

3)每一个 ChannelPipeline 内部都含有多个 ChannelHandlerContext(以下简称 Context)

4)**他们一起组成了双向链表**，这些Context 用于包装我们调用 addLast方法时添加的 ChannelHandler(以下简称handler )

![](images/27.三者关系示意图.jpg)

- 上图中：ChannelSocket 和  ChannePipeline 是一对一的关联关系，而 pipeline 内部的多个 Context 形成了链表，**Context只是对Handler的封装**
- 当一个请求进来的时候，会进入 Socket 对应的 pipeline，并经过 pipeine 所有的 handle，这就是设计模式中的过滤器模式(一般和责任链模式一起)。

### ChannelPipeLine 作用及设计

pipeline 的接口设计

![](images/28.ChannelPipeLine UML.jpg)

可以看到该接口继承了 inBound，outBound，Iterable 接口，表示他可以调用**数据出站的方法和入站**的方法，同时也能遍历内部的链表， 看看他的几个代表性的方法，基本上都是针对 handler 链表的插入，追加，删除，替换操作，类似是一个 LinkedList。同时，也能返回 channel(也就是 socket)

1）在 pipeline 的接口文档上，提供了一幅图

![](images/29.pipeline 文档图.jpg)

**对上图的解释说明：**

这是一个 handler 的 list，handler 用于处理或拦截入站事件和出站事件，pipeline 实现了过滤器的高级形式，以便用户控制事件如何处理以及 handler在pipeline 中如何交互。

上图指述了一个典型的 handler在pipeline中处理I/O事件的方式，IO事件由 inboundhandler 或者 outBoundHandler 处理，并通过调用 channelHandlerContext.fireChannelRead（以 inboundhandler 为例） 方法转发给其最近的处理程序

![](images/30.fireChannelRead解读.jpg)

![](images/31.fireChannelRead解读.jpg)

入站事件由入站处理程序以自下而上的方向处理，如上链表图所示。入站处理程序通常处理由图底部的 I/O 线程生成入站数据。入站数据通常从如 SocketChannel.read(ByteBuffer)获取。

通常一个 pipeline 有多个 handler，例如，一个典型的服务器在每个通道的管道中都会有以下处理程序

​	协议解码器 - 将二进制数据转换为 Java 对象。

​	协议编码器 - 将Java 对象转换为二进制数据。

​	业务逻辑处理程序 - 执行实际业务逻辑(例如数据库访问)

你的业务程序不能将线程阻塞，会影响 IO 的速度，进而影响整个 Netty 程序的性能。如果你的业务程序很快，就可以放在 IO 线程中，反之，你需要异步执行。或者在添加 handler 的时候添加一个线程池，例如:

// 下面这个任务执行的时候，将不会阻塞 IO 线程，执行的线程来自 group 线程池  pipeline,addLast(group, “handler", new lyBusinessLogicHandler())





