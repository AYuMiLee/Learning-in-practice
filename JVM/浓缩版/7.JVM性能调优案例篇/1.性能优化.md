## JVM优化之JIT优化

### 堆，是分配对象的唯一选择吗

在《深入理解Java虚拟机中》关于Java堆内存有这样一段描述：

随着JIT编译期的发展与逃逸分析技术逐渐成熟，**栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。**

在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过<font color = 'red'>逃逸分析(Escape Analysis)</font>后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成<font color = 'red'>栈上分配</font>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。

此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。

### 编译的开销

#### 时间开销

编译的时间开销：

解释器的执行，抽象的看是这样的:
输入的代码 -> [ 解释器 解释执行 ] -> 执行结果

JIT编译然后再执行的话，抽象的看则是:
输入的代码 -> [ 编译器 编译 ] -> 编译后的代码 -> [ 执行 ] -> 执行结果

注意：
说JIT比解释快，其实说的是“执行编译后的代码”比“解释器解释执行”要快，并不是说“编译”这个动作比“解释”这个动作快。JIT编译再怎么快，至少也比解释执行一次略慢一些，而要得到最后的执行结果还得再经过一个“执行编译后的代码”的过程。所以，<font color = 'red'>对“只执行一次”的代码而言，解释执行其实总是比JIT编译执行要快</font>。怎么算是`只执行一次的代码`呢？粗略说，下面条件同时满足时就是严格的`只执行一次。

- 只被调用一次，例如类的构造器（class initializer，()）
- 没有循环，对只执行一次的代码做JIT编译再执行，可以说是得不偿失。
- 对只执行少量次数的代码，JIT编译带来的执行速度的提升也未必能抵消掉最初编译带来的开销。

<font color = 'red'>只有对频繁执行的代码（热点代码），JIT编译才能保证有正面的收益。</font>

#### 空间开销

对一般的Java方法而言，编译后代码的大小相对于字节码的大小，膨胀比达到10+是很正常的。同上面说的时间开销一样，这里的空间开销也是，只有对执行频繁的代码才值得编译，如果把所有代码都编译则会显著增加代码所占空间，导致代码爆炸。这也就解释了为什么有些JVM会选择不总是做JIT编译，而是选择用解释器+JIT编译器的混合执行引擎。

 
