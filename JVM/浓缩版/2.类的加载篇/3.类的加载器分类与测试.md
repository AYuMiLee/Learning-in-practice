## 类加载器的分类说明

JVM支持两种类型的类加载器，分别为<font color = 'red'>引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</font>。

从概念上来讲，用户自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。<font color = 'red'>即下图中扩展类加载器、应用程序类加载器、用户自定义类加载器都被划分为自定义类加载器</font>

无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：

![](images/9.类加载器结构.jpeg)

## 子父类加载器的关系

- 除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。 
- 不同类加载器看似是继承（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。

```java
class ClassLoader{
    ClassLoader parent; //父类加载器 
    public ClassLoader(ClassLoader parent){ 
        this.parent = parent;
    }
}
class ParentClassLoader extends ClassLoader{
     public ParentClassLoader(ClassLoader parent){
          super(parent);
     }
}
class ChildClassLoader extends ClassLoader{
     public ChildClassLoader(ClassLoader parent){ //parent = new ParentClassLoader();
          super(parent);
     }
}
```
## 具体类的加载器介绍

### 引导类加载器

<font color = 'red'>启动类加载器（引导类加载器，Bootstrap ClassLoader）</font>

- 这个类加载使用C/C++语言实现的，嵌套在JVM内部。
- 它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。
- 并不继承自java.lang.ClassLoader，没有父加载器。
- 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类
- 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。

 使用-XX:+TraceClassLoading参数得到启动类加载器相关信息。

![](images/10.启动类加载器日志.jpeg)

![](images/11.启动类加载器日志.jpeg)

启动类加载器使用C++编写的? Yes!

- C/C++：指针函数&函数指针、C++支持多继承
- Java：由C++演变而来，(C++)--版，单继承

### 扩展类加载器

<font color = 'red'>扩展类加载器（Extension ClassLoader）</font>

- Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。
- 继承于ClassLoader类
- 父类加载器为启动类加载器
- 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。

![](images/12.扩展类加载器.jpeg)

## 系统类加载器

<font color = 'red'>应用程序类加载器（系统类加载器，AppClassLoader）</font>

- java语言编写，由sun.misc.Launcher$AppClassLoader实现
- 继承于ClassLoader类
- 父类加载器为扩展类加载器
- 它负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库 
- <font color = 'red'>应用程序中的类加载器默认是系统类加载器。</font>
- 它是用户自定义类加载器的默认父加载器
- 通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器

 

 

 





